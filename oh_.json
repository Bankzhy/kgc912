{"project": "jsprit", "code": "public static void addCoreConstraints(ConstraintManager constraintManager, StateManager stateManager, final VehicleRoutingProblem vrp){\n        Collection<Job> allJobs = vrp.getJobsInclusiveInitialJobsInRoutes().values();\n        boolean anyJobsWithoutLocation = allJobs.stream().flatMap(job -> job.getActivities().stream()).anyMatch(activity -> activity.getLocation() == null);\n\n        if (anyJobsWithoutLocation) {\n            stateManager.addStateUpdater(new UpdateActivityNextLocations());\n            stateManager.addStateUpdater(new UpdateActivityPrevLocations());\n        }\n        constraintManager.addTimeWindowConstraint();\n        constraintManager.addLoadConstraint();\n        constraintManager.addSkillsConstraint();\n        constraintManager.addConstraint(new SwitchNotFeasible(stateManager));\n        stateManager.updateLoadStates();\n        stateManager.updateTimeWindowStates();\n        UpdateVehicleDependentPracticalTimeWindows twUpdater = new UpdateVehicleDependentPracticalTimeWindows(stateManager, vrp.getTransportCosts(), vrp.getActivityCosts());\n        twUpdater.setVehiclesToUpdate(new UpdateVehicleDependentPracticalTimeWindows.VehiclesToUpdate() {\n\n            Map<VehicleTypeKey, Vehicle> uniqueTypes = new HashMap<>();\n\n            @Override\n            public Collection<Vehicle> get(VehicleRoute vehicleRoute) {\n                if (uniqueTypes.isEmpty()) {\n                    for (Vehicle v : vrp.getVehicles()) {\n                        if (!uniqueTypes.containsKey(v.getVehicleTypeIdentifier())) {\n                            uniqueTypes.put(v.getVehicleTypeIdentifier(), v);\n                        }\n                    }\n                }\n                return new ArrayList<>(uniqueTypes.values());\n            }\n\n        });\n        stateManager.addStateUpdater(new UpdateEndLocationIfRouteIsOpen());\n        stateManager.addStateUpdater(twUpdater);\n        stateManager.updateSkillStates();\n\n        stateManager.addStateUpdater(new UpdateActivityTimes(vrp.getTransportCosts(), ActivityTimeTracker.ActivityPolicy.AS_SOON_AS_TIME_WINDOW_OPENS, vrp.getActivityCosts()));\n        stateManager.addStateUpdater(new UpdateVariableCosts(vrp.getActivityCosts(), vrp.getTransportCosts(), stateManager));\n        stateManager.addStateUpdater(new UpdateFutureWaitingTimes(stateManager, vrp.getTransportCosts()));\n    }", "method_name": "addCoreConstraints", "kg": [{"source": {"label": "ConstraintManager", "type": "datatype"}, "target": {"label": "constraintManager", "type": "var"}, "type": "type_of"}, {"source": {"label": "StateManager", "type": "datatype"}, "target": {"label": "stateManager", "type": "var"}, "type": "type_of"}, {"source": {"label": "final", "type": "datatype"}, "target": {"label": "VehicleRoutingProblem", "type": "var"}, "type": "type_of"}, {"source": {"label": "vrp.getJobsInclusiveInitialJobsInRoutes()", "type": "var"}, "target": {"label": "values", "type": "method"}, "type": "has_method"}, {"source": {"label": "allJobs_0", "type": "var_assignment"}, "target": {"label": "allJobs", "type": "var"}, "type": "assignment"}, {"source": {"label": "allJobs.stream().flatMap(job -> job.getActivities().stream())", "type": "var"}, "target": {"label": "anyMatch", "type": "method"}, "type": "has_method"}, {"source": {"label": "anyJobsWithoutLocation_0", "type": "var_assignment"}, "target": {"label": "anyJobsWithoutLocation", "type": "var"}, "type": "assignment"}, {"source": {"label": "stateManager", "type": "var"}, "target": {"label": "addStateUpdater", "type": "method"}, "type": "has_method"}, {"source": {"label": "constraintManager", "type": "var"}, "target": {"label": "addTimeWindowConstraint", "type": "method"}, "type": "has_method"}, {"source": {"label": "constraintManager", "type": "var"}, "target": {"label": "addLoadConstraint", "type": "method"}, "type": "has_method"}, {"source": {"label": "constraintManager", "type": "var"}, "target": {"label": "addSkillsConstraint", "type": "method"}, "type": "has_method"}, {"source": {"label": "constraintManager", "type": "var"}, "target": {"label": "addConstraint", "type": "method"}, "type": "has_method"}, {"source": {"label": "stateManager", "type": "var"}, "target": {"label": "updateLoadStates", "type": "method"}, "type": "has_method"}, {"source": {"label": "stateManager", "type": "var"}, "target": {"label": "updateTimeWindowStates", "type": "method"}, "type": "has_method"}, {"source": {"label": "twUpdater_0", "type": "var_assignment"}, "target": {"label": "twUpdater", "type": "var"}, "type": "assignment"}, {"source": {"label": "twUpdater", "type": "var"}, "target": {"label": "setVehiclesToUpdate", "type": "method"}, "type": "has_method"}, {"source": {"label": "stateManager", "type": "var"}, "target": {"label": "updateSkillStates", "type": "method"}, "type": "has_method"}]}
{"project": "jsprit", "code": "private List<Job> getUnassignedJobs(VehicleRoutingProblem vrp) {\n        return new ArrayList<>(vrp.getJobs().values());\n    }", "method_name": "getUnassignedJobs", "kg": [{"source": {"label": "VehicleRoutingProblem", "type": "datatype"}, "target": {"label": "vrp", "type": "var"}, "type": "type_of"}]}
{"project": "jsprit", "code": "public PrettyAlgorithmBuilder withObjectiveFunction(SolutionCostCalculator objectiveFunction) {\n        this.objectiveFunction = objectiveFunction;\n        return this;\n    }", "method_name": "withObjectiveFunction", "kg": [{"source": {"label": "SolutionCostCalculator", "type": "datatype"}, "target": {"label": "objectiveFunction", "type": "var"}, "type": "type_of"}, {"source": {"label": "objectiveFunction_0", "type": "var_assignment"}, "target": {"label": "objectiveFunction", "type": "var"}, "type": "assignment"}, {"source": {"label": "objectiveFunction_0", "type": "var_assignment"}, "target": {"label": "objectiveFunction_0", "type": "var_assignment"}, "type": "data_dependency"}]}
{"project": "jsprit", "code": "@Override\n    public void informInsertionEnds(Collection<VehicleRoute> vehicleRoutes, Collection<Job> badJobs) {\n        for (Iterator<VehicleRoute> iterator = vehicleRoutes.iterator(); iterator.hasNext(); ) {\n            VehicleRoute route = iterator.next();\n            if (route.isEmpty()) {\n                fleetManager.unlock(route.getVehicle());\n                iterator.remove();\n            }\n        }\n    }", "method_name": "informInsertionEnds", "kg": [{"source": {"label": "Collection<VehicleRoute>", "type": "datatype"}, "target": {"label": "vehicleRoutes", "type": "var"}, "type": "type_of"}, {"source": {"label": "Collection<Job>", "type": "datatype"}, "target": {"label": "badJobs", "type": "var"}, "type": "type_of"}, {"source": {"label": "iterator", "type": "var"}, "target": {"label": "next", "type": "method"}, "type": "has_method"}, {"source": {"label": "route_0", "type": "var_assignment"}, "target": {"label": "route", "type": "var"}, "type": "assignment"}, {"source": {"label": "fleetManager", "type": "var"}, "target": {"label": "unlock", "type": "method"}, "type": "has_method"}, {"source": {"label": "iterator", "type": "var"}, "target": {"label": "remove", "type": "method"}, "type": "has_method"}, {"source": {"label": "vehicleRoutes", "type": "var"}, "target": {"label": "iterator", "type": "method"}, "type": "has_method"}, {"source": {"label": "iterator_0", "type": "var_assignment"}, "target": {"label": "iterator", "type": "var"}, "type": "assignment"}]}
{"project": "jsprit", "code": "@Override\n    public String toString() {\n        return \"[name=resetAndIniFleetManager]\";\n    }", "method_name": "toString", "kg": []}
{"project": "jsprit", "code": "public void addModuleListener(SearchStrategyModuleListener moduleListener) {\n        for (SearchStrategyModule module : searchStrategyModules) {\n            module.addModuleListener(moduleListener);\n        }\n\n    }", "method_name": "addModuleListener", "kg": [{"source": {"label": "SearchStrategyModuleListener", "type": "datatype"}, "target": {"label": "moduleListener", "type": "var"}, "type": "type_of"}, {"source": {"label": "module", "type": "var"}, "target": {"label": "addModuleListener", "type": "method"}, "type": "has_method"}]}
{"project": "jsprit", "code": "public void addSearchStrategyModuleListener(SearchStrategyModuleListener moduleListener) {\n        for (SearchStrategy s : strategies) {\n            s.addModuleListener(moduleListener);\n        }\n    }", "method_name": "addSearchStrategyModuleListener", "kg": [{"source": {"label": "SearchStrategyModuleListener", "type": "datatype"}, "target": {"label": "moduleListener", "type": "var"}, "type": "type_of"}, {"source": {"label": "s", "type": "var"}, "target": {"label": "addModuleListener", "type": "method"}, "type": "has_method"}]}
{"project": "jsprit", "code": "public SolutionCostCalculator createCalculator() {\n        return new SolutionCostCalculator() {\n\n            @Override\n            public double getCosts(VehicleRoutingProblemSolution solution) {\n                double c = 0.0;\n                for (VehicleRoute r : solution.getRoutes()) {\n                    c += stateManager.getRouteState(r, InternalStates.COSTS, Double.class);\n                    c += getFixedCosts(r.getVehicle());\n                }\n                c += solution.getUnassignedJobs().size() * c * .1;\n                return c;\n            }\n\n            private double getFixedCosts(Vehicle vehicle) {\n                if (vehicle == null) return 0.0;\n                if (vehicle.getType() == null) return 0.0;\n                return vehicle.getType().getVehicleCostParams().fix;\n            }\n        };\n    }", "method_name": "createCalculator", "kg": []}
{"project": "jsprit", "code": "public SolutionCostCalculator getObjectiveFunction(){\n        return objectiveFunction;\n    }", "method_name": "getObjectiveFunction", "kg": []}
{"project": "jsprit", "code": "@Override\n    public String toString() {\n        return \"[name=acceptNewRemoveFirst]\";\n    }", "method_name": "toString", "kg": []}
{"project": "jsprit", "code": "@Override\n    public void informIterationStarts(int i, VehicleRoutingProblem problem, Collection<VehicleRoutingProblemSolution> solutions) {\n        currentIteration = i;\n    }", "method_name": "informIterationStarts", "kg": [{"source": {"label": "int", "type": "datatype"}, "target": {"label": "i", "type": "var"}, "type": "type_of"}, {"source": {"label": "VehicleRoutingProblem", "type": "datatype"}, "target": {"label": "problem", "type": "var"}, "type": "type_of"}, {"source": {"label": "Collection<VehicleRoutingProblemSolution>", "type": "datatype"}, "target": {"label": "solutions", "type": "var"}, "type": "type_of"}, {"source": {"label": "currentIteration_0", "type": "var_assignment"}, "target": {"label": "currentIteration", "type": "var"}, "type": "assignment"}]}
{"project": "jsprit", "code": "@Override\n    public String toString() {\n        return \"[name=GreedyAcceptance]\";\n    }", "method_name": "toString", "kg": []}
{"project": "jsprit", "code": "@Override\n    public void informIterationStarts(int i, VehicleRoutingProblem problem, Collection<VehicleRoutingProblemSolution> solutions) {\n        currentIteration = i;\n    }", "method_name": "informIterationStarts", "kg": [{"source": {"label": "int", "type": "datatype"}, "target": {"label": "i", "type": "var"}, "type": "type_of"}, {"source": {"label": "VehicleRoutingProblem", "type": "datatype"}, "target": {"label": "problem", "type": "var"}, "type": "type_of"}, {"source": {"label": "Collection<VehicleRoutingProblemSolution>", "type": "datatype"}, "target": {"label": "solutions", "type": "var"}, "type": "type_of"}, {"source": {"label": "currentIteration_0", "type": "var_assignment"}, "target": {"label": "currentIteration", "type": "var"}, "type": "assignment"}]}
{"project": "jsprit", "code": "@Override\n    public void informIterationStarts(int i, VehicleRoutingProblem problem, Collection<VehicleRoutingProblemSolution> solutions) {\n        currentIteration = i;\n    }", "method_name": "informIterationStarts", "kg": [{"source": {"label": "int", "type": "datatype"}, "target": {"label": "i", "type": "var"}, "type": "type_of"}, {"source": {"label": "VehicleRoutingProblem", "type": "datatype"}, "target": {"label": "problem", "type": "var"}, "type": "type_of"}, {"source": {"label": "Collection<VehicleRoutingProblemSolution>", "type": "datatype"}, "target": {"label": "solutions", "type": "var"}, "type": "type_of"}, {"source": {"label": "currentIteration_0", "type": "var_assignment"}, "target": {"label": "currentIteration", "type": "var"}, "type": "assignment"}]}
{"project": "jsprit", "code": "@Override\n    public void informAlgorithmStarts(VehicleRoutingProblem problem, VehicleRoutingAlgorithm algorithm, Collection<VehicleRoutingProblemSolution> solutions) {\n        logger.info(\"prepare schrimpfAcceptanceFunction, i.e. determine initial threshold\");\n        double now = System.currentTimeMillis();\n\n\t\t/*\n         * randomWalk to determine standardDev\n\t\t */\n        final double[] results = new double[nOfRandomWalks];\n\n        Jsprit.Builder builder = new GreedySchrimpfFactory().createGreedyAlgorithmBuilder(problem);\n        builder.setCustomAcceptor(new AcceptNewRemoveFirst(1));\n        VehicleRoutingAlgorithm vra = builder.buildAlgorithm();\n        vra.setMaxIterations(nOfRandomWalks);\n        vra.getAlgorithmListeners().addListener(new IterationEndsListener() {\n\n            @Override\n            public void informIterationEnds(int iteration, VehicleRoutingProblem problem, Collection<VehicleRoutingProblemSolution> solutions) {\n                double result = Solutions.bestOf(solutions).getCost();\n//\t\t\t\tlogger.info(\"result={}\", result);\n                results[iteration - 1] = result;\n            }\n\n        });\n        vra.searchSolutions();\n\n        StandardDeviation dev = new StandardDeviation();\n        double standardDeviation = dev.evaluate(results);\n        double initialThreshold = standardDeviation / 2;\n\n        schrimpfAcceptance.setInitialThreshold(initialThreshold);\n\n        logger.info(\"took {} seconds\", ((System.currentTimeMillis() - now) / 1000.0));\n        logger.debug(\"initial threshold: {}\", initialThreshold);\n        logger.info(\"---------------------------------------------------------------------\");\n    }", "method_name": "informAlgorithmStarts", "kg": [{"source": {"label": "VehicleRoutingProblem", "type": "datatype"}, "target": {"label": "problem", "type": "var"}, "type": "type_of"}, {"source": {"label": "VehicleRoutingAlgorithm", "type": "datatype"}, "target": {"label": "algorithm", "type": "var"}, "type": "type_of"}, {"source": {"label": "Collection<VehicleRoutingProblemSolution>", "type": "datatype"}, "target": {"label": "solutions", "type": "var"}, "type": "type_of"}, {"source": {"label": "logger", "type": "var"}, "target": {"label": "info", "type": "method"}, "type": "has_method"}, {"source": {"label": "System", "type": "datatype"}, "target": {"label": "currentTimeMillis", "type": "method"}, "type": "has_method"}, {"source": {"label": "now_0", "type": "var_assignment"}, "target": {"label": "now", "type": "var"}, "type": "assignment"}, {"source": {"label": "results_0", "type": "var_assignment"}, "target": {"label": "results", "type": "var"}, "type": "assignment"}, {"source": {"label": "new GreedySchrimpfFactory()", "type": "var"}, "target": {"label": "createGreedyAlgorithmBuilder", "type": "method"}, "type": "has_method"}, {"source": {"label": "builder_0", "type": "var_assignment"}, "target": {"label": "builder", "type": "var"}, "type": "assignment"}, {"source": {"label": "builder", "type": "var"}, "target": {"label": "setCustomAcceptor", "type": "method"}, "type": "has_method"}, {"source": {"label": "builder", "type": "var"}, "target": {"label": "buildAlgorithm", "type": "method"}, "type": "has_method"}, {"source": {"label": "vra_0", "type": "var_assignment"}, "target": {"label": "vra", "type": "var"}, "type": "assignment"}, {"source": {"label": "vra", "type": "var"}, "target": {"label": "setMaxIterations", "type": "method"}, "type": "has_method"}, {"source": {"label": "vra.getAlgorithmListeners()", "type": "var"}, "target": {"label": "addListener", "type": "method"}, "type": "has_method"}, {"source": {"label": "vra", "type": "var"}, "target": {"label": "searchSolutions", "type": "method"}, "type": "has_method"}, {"source": {"label": "dev_0", "type": "var_assignment"}, "target": {"label": "dev", "type": "var"}, "type": "assignment"}, {"source": {"label": "dev", "type": "var"}, "target": {"label": "evaluate", "type": "method"}, "type": "has_method"}, {"source": {"label": "standardDeviation_0", "type": "var_assignment"}, "target": {"label": "standardDeviation", "type": "var"}, "type": "assignment"}, {"source": {"label": "initialThreshold_0", "type": "var_assignment"}, "target": {"label": "initialThreshold", "type": "var"}, "type": "assignment"}, {"source": {"label": "schrimpfAcceptance", "type": "var"}, "target": {"label": "setInitialThreshold", "type": "method"}, "type": "has_method"}, {"source": {"label": "logger", "type": "var"}, "target": {"label": "debug", "type": "method"}, "type": "has_method"}]}
{"project": "jsprit", "code": "public void setRandom(Random random) {\n        this.random = random;\n    }", "method_name": "setRandom", "kg": [{"source": {"label": "Random", "type": "datatype"}, "target": {"label": "random", "type": "var"}, "type": "type_of"}, {"source": {"label": "random_0", "type": "var_assignment"}, "target": {"label": "random", "type": "var"}, "type": "assignment"}, {"source": {"label": "random_0", "type": "var_assignment"}, "target": {"label": "random_0", "type": "var_assignment"}, "type": "data_dependency"}]}
{"project": "jsprit", "code": "public Jsprit.Builder createGreedyAlgorithmBuilder(VehicleRoutingProblem vrp) {\n        int radialShare = (int) (vrp.getJobs().size() * 0.3);\n        int randomShare = (int) (vrp.getJobs().size() * 0.5);\n\n        Jsprit.Builder builder = Jsprit.Builder.newInstance(vrp);\n        builder.setProperty(Jsprit.Parameter.THRESHOLD_ALPHA,\"0.0\");\n        builder.setProperty(Jsprit.Strategy.RADIAL_BEST, \"0.5\");\n        builder.setProperty(Jsprit.Strategy.RADIAL_REGRET, \"0.0\");\n        builder.setProperty(Jsprit.Strategy.RANDOM_BEST, \"0.5\");\n        builder.setProperty(Jsprit.Strategy.RANDOM_REGRET, \"0.0\");\n        builder.setProperty(Jsprit.Strategy.WORST_BEST, \"0.0\");\n        builder.setProperty(Jsprit.Strategy.WORST_REGRET, \"0.0\");\n        builder.setProperty(Jsprit.Strategy.CLUSTER_BEST, \"0.0\");\n        builder.setProperty(Jsprit.Strategy.CLUSTER_REGRET, \"0.0\");\n        builder.setProperty(Jsprit.Parameter.RADIAL_MIN_SHARE, String.valueOf(radialShare));\n        builder.setProperty(Jsprit.Parameter.RADIAL_MAX_SHARE, String.valueOf(radialShare));\n        builder.setProperty(Jsprit.Parameter.RANDOM_BEST_MIN_SHARE, String.valueOf(randomShare));\n        builder.setProperty(Jsprit.Parameter.RANDOM_BEST_MAX_SHARE, String.valueOf(randomShare));\n        return builder;\n    }", "method_name": "createGreedyAlgorithmBuilder", "kg": [{"source": {"label": "VehicleRoutingProblem", "type": "datatype"}, "target": {"label": "vrp", "type": "var"}, "type": "type_of"}, {"source": {"label": "radialShare_0", "type": "var_assignment"}, "target": {"label": "radialShare", "type": "var"}, "type": "assignment"}, {"source": {"label": "randomShare_0", "type": "var_assignment"}, "target": {"label": "randomShare", "type": "var"}, "type": "assignment"}, {"source": {"label": "Jsprit.Builder", "type": "datatype"}, "target": {"label": "newInstance", "type": "method"}, "type": "has_method"}, {"source": {"label": "builder_0", "type": "var_assignment"}, "target": {"label": "builder", "type": "var"}, "type": "assignment"}, {"source": {"label": "builder", "type": "var"}, "target": {"label": "setProperty", "type": "method"}, "type": "has_method"}]}
{"project": "jsprit", "code": "public void setRandom(Random random) {\n        this.random = random;\n    }", "method_name": "setRandom", "kg": [{"source": {"label": "Random", "type": "datatype"}, "target": {"label": "random", "type": "var"}, "type": "type_of"}, {"source": {"label": "random_0", "type": "var_assignment"}, "target": {"label": "random", "type": "var"}, "type": "assignment"}, {"source": {"label": "random_0", "type": "var_assignment"}, "target": {"label": "random_0", "type": "var_assignment"}, "type": "data_dependency"}]}
{"project": "jsprit", "code": "private SolutionCostCalculator getObjectiveFunction(final VehicleRoutingProblem vrp, final double maxCosts) {\n        if (objectiveFunction != null) return objectiveFunction;\n\n        SolutionCostCalculator solutionCostCalculator = new SolutionCostCalculator() {\n            @Override\n            public double getCosts(VehicleRoutingProblemSolution solution) {\n                double costs = 0.;\n\n                for (VehicleRoute route : solution.getRoutes()) {\n                    costs += route.getVehicle().getType().getVehicleCostParams().fix;\n                    boolean hasBreak = false;\n                    TourActivity prevAct = route.getStart();\n                    for (TourActivity act : route.getActivities()) {\n                        if (act instanceof BreakActivity) hasBreak = true;\n                        costs += vrp.getTransportCosts().getTransportCost(prevAct.getLocation(), act.getLocation(), prevAct.getEndTime(), route.getDriver(), route.getVehicle());\n                        costs += vrp.getActivityCosts().getActivityCost(act, act.getArrTime(), route.getDriver(), route.getVehicle());\n                        prevAct = act;\n                    }\n                    costs += vrp.getTransportCosts().getTransportCost(prevAct.getLocation(), route.getEnd().getLocation(), prevAct.getEndTime(), route.getDriver(), route.getVehicle());\n                    if (route.getVehicle().getBreak() != null) {\n                        if (!hasBreak) {\n                            //break defined and required but not assigned penalty\n                            if (route.getEnd().getArrTime() > route.getVehicle().getBreak().getTimeWindow().getEnd()) {\n                                costs += 4 * (maxCosts * 2 + route.getVehicle().getBreak().getServiceDuration() * route.getVehicle().getType().getVehicleCostParams().perServiceTimeUnit);\n                            }\n                        }\n                    }\n                }\n                for(Job j : solution.getUnassignedJobs()){\n                    costs += maxCosts * 2 * (11 - j.getPriority());\n                }\n                return costs;\n            }\n        };\n        return solutionCostCalculator;\n    }", "method_name": "getObjectiveFunction", "kg": [{"source": {"label": "final", "type": "datatype"}, "target": {"label": "VehicleRoutingProblem", "type": "var"}, "type": "type_of"}, {"source": {"label": "final", "type": "datatype"}, "target": {"label": "double", "type": "var"}, "type": "type_of"}, {"source": {"label": "solutionCostCalculator_0", "type": "var_assignment"}, "target": {"label": "solutionCostCalculator", "type": "var"}, "type": "assignment"}]}
{"project": "jsprit", "code": "public VehicleRoutingAlgorithm createAlgorithm(VehicleRoutingProblem vrp) {\n        //TODO determine alpha threshold\n\n        int radialShare = (int) (vrp.getJobs().size() * 0.3);\n        int randomShare = (int) (vrp.getJobs().size() * 0.5);\n        Jsprit.Builder builder = Jsprit.Builder.newInstance(vrp);\n        builder.setProperty(Jsprit.Parameter.THRESHOLD_ALPHA,\"0.0\");\n        builder.setProperty(Jsprit.Strategy.RADIAL_BEST, \"0.5\");\n        builder.setProperty(Jsprit.Strategy.RADIAL_REGRET, \"0.0\");\n        builder.setProperty(Jsprit.Strategy.RANDOM_BEST, \"0.5\");\n        builder.setProperty(Jsprit.Strategy.RANDOM_REGRET, \"0.0\");\n        builder.setProperty(Jsprit.Strategy.WORST_BEST, \"0.0\");\n        builder.setProperty(Jsprit.Strategy.WORST_REGRET, \"0.0\");\n        builder.setProperty(Jsprit.Strategy.CLUSTER_BEST, \"0.0\");\n        builder.setProperty(Jsprit.Strategy.CLUSTER_REGRET, \"0.0\");\n        builder.setProperty(Jsprit.Parameter.RADIAL_MIN_SHARE, String.valueOf(radialShare));\n        builder.setProperty(Jsprit.Parameter.RADIAL_MAX_SHARE, String.valueOf(radialShare));\n        builder.setProperty(Jsprit.Parameter.RANDOM_BEST_MIN_SHARE, String.valueOf(randomShare));\n        builder.setProperty(Jsprit.Parameter.RANDOM_BEST_MAX_SHARE, String.valueOf(randomShare));\n        return builder.buildAlgorithm();\n    }", "method_name": "createAlgorithm", "kg": [{"source": {"label": "VehicleRoutingProblem", "type": "datatype"}, "target": {"label": "vrp", "type": "var"}, "type": "type_of"}, {"source": {"label": "radialShare_0", "type": "var_assignment"}, "target": {"label": "radialShare", "type": "var"}, "type": "assignment"}, {"source": {"label": "randomShare_0", "type": "var_assignment"}, "target": {"label": "randomShare", "type": "var"}, "type": "assignment"}, {"source": {"label": "Jsprit.Builder", "type": "datatype"}, "target": {"label": "newInstance", "type": "method"}, "type": "has_method"}, {"source": {"label": "builder_0", "type": "var_assignment"}, "target": {"label": "builder", "type": "var"}, "type": "assignment"}, {"source": {"label": "builder", "type": "var"}, "target": {"label": "setProperty", "type": "method"}, "type": "has_method"}]}
{"project": "jsprit", "code": "public void selectedStrategy(SearchStrategy.DiscoveredSolution discoveredSolution, VehicleRoutingProblem problem, Collection<VehicleRoutingProblemSolution> solutions) {\n        for (PrioritizedVRAListener l : algorithmListeners) {\n            if (l.getListener() instanceof StrategySelectedListener) {\n                ((StrategySelectedListener) l.getListener()).informSelectedStrategy(discoveredSolution, problem, solutions);\n            }\n        }\n    }", "method_name": "selectedStrategy", "kg": [{"source": {"label": "SearchStrategy.DiscoveredSolution", "type": "datatype"}, "target": {"label": "discoveredSolution", "type": "var"}, "type": "type_of"}, {"source": {"label": "VehicleRoutingProblem", "type": "datatype"}, "target": {"label": "problem", "type": "var"}, "type": "type_of"}, {"source": {"label": "Collection<VehicleRoutingProblemSolution>", "type": "datatype"}, "target": {"label": "solutions", "type": "var"}, "type": "type_of"}, {"source": {"label": "((StrategySelectedListener) l.getListener())", "type": "var"}, "target": {"label": "informSelectedStrategy", "type": "method"}, "type": "has_method"}]}
{"project": "jsprit", "code": "public RuinStrategy getRuin() {\n        return ruin;\n    }", "method_name": "getRuin", "kg": []}
{"project": "jsprit", "code": "ConstraintsStatus fulfilled(JobInsertionContext iFacts, TourActivity prevAct, TourActivity newAct, TourActivity nextAct, double prevActDepTime, Collection<HardConstraint> failedActivityConstraints, ConstraintManager constraintManager) {\n        if (!constraintManager.hasHardActivityConstraints()) return ConstraintsStatus.FULFILLED;\n        ConstraintsStatus notFulfilled = null;\n        List<HardConstraint> failed = new ArrayList<>();\n        for (HardActivityConstraint c : constraintManager.getCriticalHardActivityConstraints()) {\n            ConstraintsStatus status = c.fulfilled(iFacts, prevAct, newAct, nextAct, prevActDepTime);\n            if (status.equals(ConstraintsStatus.NOT_FULFILLED_BREAK)) {\n                failedActivityConstraints.add(c);\n                return status;\n            } else {\n                if (status.equals(ConstraintsStatus.NOT_FULFILLED)) {\n                    failed.add(c);\n                    notFulfilled = status;\n                }\n            }\n        }\n        if (notFulfilled != null) {\n            failedActivityConstraints.addAll(failed);\n            return notFulfilled;\n        }\n\n        for (HardActivityConstraint c : constraintManager.getHighPrioHardActivityConstraints()) {\n            ConstraintsStatus status = c.fulfilled(iFacts, prevAct, newAct, nextAct, prevActDepTime);\n            if (status.equals(ConstraintsStatus.NOT_FULFILLED_BREAK)) {\n                failedActivityConstraints.add(c);\n                return status;\n            } else {\n                if (status.equals(ConstraintsStatus.NOT_FULFILLED)) {\n                    failed.add(c);\n                    notFulfilled = status;\n                }\n            }\n        }\n        if (notFulfilled != null) {\n            failedActivityConstraints.addAll(failed);\n            return notFulfilled;\n        }\n\n        for (HardActivityConstraint constraint : constraintManager.getLowPrioHardActivityConstraints()) {\n            ConstraintsStatus status = constraint.fulfilled(iFacts, prevAct, newAct, nextAct, prevActDepTime);\n            if (status.equals(ConstraintsStatus.NOT_FULFILLED_BREAK) || status.equals(ConstraintsStatus.NOT_FULFILLED)) {\n                failedActivityConstraints.add(constraint);\n                return status;\n            }\n        }\n        return ConstraintsStatus.FULFILLED;\n    }", "method_name": "fulfilled", "kg": [{"source": {"label": "JobInsertionContext", "type": "datatype"}, "target": {"label": "iFacts", "type": "var"}, "type": "type_of"}, {"source": {"label": "TourActivity", "type": "datatype"}, "target": {"label": "prevAct", "type": "var"}, "type": "type_of"}, {"source": {"label": "TourActivity", "type": "datatype"}, "target": {"label": "newAct", "type": "var"}, "type": "type_of"}, {"source": {"label": "TourActivity", "type": "datatype"}, "target": {"label": "nextAct", "type": "var"}, "type": "type_of"}, {"source": {"label": "double", "type": "datatype"}, "target": {"label": "prevActDepTime", "type": "var"}, "type": "type_of"}, {"source": {"label": "Collection<HardConstraint>", "type": "datatype"}, "target": {"label": "failedActivityConstraints", "type": "var"}, "type": "type_of"}, {"source": {"label": "ConstraintManager", "type": "datatype"}, "target": {"label": "constraintManager", "type": "var"}, "type": "type_of"}, {"source": {"label": "notFulfilled_0", "type": "var_assignment"}, "target": {"label": "notFulfilled", "type": "var"}, "type": "assignment"}, {"source": {"label": "failed_0", "type": "var_assignment"}, "target": {"label": "failed", "type": "var"}, "type": "assignment"}, {"source": {"label": "c", "type": "var"}, "target": {"label": "fulfilled", "type": "method"}, "type": "has_method"}, {"source": {"label": "status_0", "type": "var_assignment"}, "target": {"label": "status", "type": "var"}, "type": "assignment"}, {"source": {"label": "failedActivityConstraints", "type": "var"}, "target": {"label": "add", "type": "method"}, "type": "has_method"}, {"source": {"label": "failed", "type": "var"}, "target": {"label": "add", "type": "method"}, "type": "has_method"}, {"source": {"label": "notFulfilled_1", "type": "var_assignment"}, "target": {"label": "notFulfilled", "type": "var"}, "type": "assignment"}, {"source": {"label": "notFulfilled_1", "type": "var_assignment"}, "target": {"label": "status_0", "type": "var_assignment"}, "type": "data_dependency"}, {"source": {"label": "failedActivityConstraints", "type": "var"}, "target": {"label": "addAll", "type": "method"}, "type": "has_method"}, {"source": {"label": "notFulfilled_2", "type": "var_assignment"}, "target": {"label": "notFulfilled", "type": "var"}, "type": "assignment"}, {"source": {"label": "notFulfilled_2", "type": "var_assignment"}, "target": {"label": "status_0", "type": "var_assignment"}, "type": "data_dependency"}, {"source": {"label": "constraint", "type": "var"}, "target": {"label": "fulfilled", "type": "method"}, "type": "has_method"}]}
{"project": "jsprit", "code": "ConstraintsStatus fulfilled(JobInsertionContext iFacts, TourActivity prevAct, TourActivity newAct, TourActivity nextAct, double prevActDepTime, Collection<HardConstraint> failedActivityConstraints, ConstraintManager constraintManager) {\n        if (!constraintManager.hasHardActivityConstraints()) return ConstraintsStatus.FULFILLED;\n        ConstraintsStatus notFulfilled = null;\n        List<HardConstraint> failed = new ArrayList<>();\n        for (HardActivityConstraint c : constraintManager.getCriticalHardActivityConstraints()) {\n            ConstraintsStatus status = c.fulfilled(iFacts, prevAct, newAct, nextAct, prevActDepTime);\n            if (status.equals(ConstraintsStatus.NOT_FULFILLED_BREAK)) {\n                failedActivityConstraints.add(c);\n                return status;\n            } else {\n                if (status.equals(ConstraintsStatus.NOT_FULFILLED)) {\n                    failed.add(c);\n                    notFulfilled = status;\n                }\n            }\n        }\n        if (notFulfilled != null) {\n            failedActivityConstraints.addAll(failed);\n            return notFulfilled;\n        }\n\n        for (HardActivityConstraint c : constraintManager.getHighPrioHardActivityConstraints()) {\n            ConstraintsStatus status = c.fulfilled(iFacts, prevAct, newAct, nextAct, prevActDepTime);\n            if (status.equals(ConstraintsStatus.NOT_FULFILLED_BREAK)) {\n                failedActivityConstraints.add(c);\n                return status;\n            } else {\n                if (status.equals(ConstraintsStatus.NOT_FULFILLED)) {\n                    failed.add(c);\n                    notFulfilled = status;\n                }\n            }\n        }\n        if (notFulfilled != null) {\n            failedActivityConstraints.addAll(failed);\n            return notFulfilled;\n        }\n\n        for (HardActivityConstraint constraint : constraintManager.getLowPrioHardActivityConstraints()) {\n            ConstraintsStatus status = constraint.fulfilled(iFacts, prevAct, newAct, nextAct, prevActDepTime);\n            if (status.equals(ConstraintsStatus.NOT_FULFILLED_BREAK) || status.equals(ConstraintsStatus.NOT_FULFILLED)) {\n                failedActivityConstraints.add(constraint);\n                return status;\n            }\n        }\n        return ConstraintsStatus.FULFILLED;\n    }", "method_name": "fulfilled", "kg": [{"source": {"label": "JobInsertionContext", "type": "datatype"}, "target": {"label": "iFacts", "type": "var"}, "type": "type_of"}, {"source": {"label": "TourActivity", "type": "datatype"}, "target": {"label": "prevAct", "type": "var"}, "type": "type_of"}, {"source": {"label": "TourActivity", "type": "datatype"}, "target": {"label": "newAct", "type": "var"}, "type": "type_of"}, {"source": {"label": "TourActivity", "type": "datatype"}, "target": {"label": "nextAct", "type": "var"}, "type": "type_of"}, {"source": {"label": "double", "type": "datatype"}, "target": {"label": "prevActDepTime", "type": "var"}, "type": "type_of"}, {"source": {"label": "Collection<HardConstraint>", "type": "datatype"}, "target": {"label": "failedActivityConstraints", "type": "var"}, "type": "type_of"}, {"source": {"label": "ConstraintManager", "type": "datatype"}, "target": {"label": "constraintManager", "type": "var"}, "type": "type_of"}, {"source": {"label": "notFulfilled_0", "type": "var_assignment"}, "target": {"label": "notFulfilled", "type": "var"}, "type": "assignment"}, {"source": {"label": "failed_0", "type": "var_assignment"}, "target": {"label": "failed", "type": "var"}, "type": "assignment"}, {"source": {"label": "c", "type": "var"}, "target": {"label": "fulfilled", "type": "method"}, "type": "has_method"}, {"source": {"label": "status_0", "type": "var_assignment"}, "target": {"label": "status", "type": "var"}, "type": "assignment"}, {"source": {"label": "failedActivityConstraints", "type": "var"}, "target": {"label": "add", "type": "method"}, "type": "has_method"}, {"source": {"label": "failed", "type": "var"}, "target": {"label": "add", "type": "method"}, "type": "has_method"}, {"source": {"label": "notFulfilled_1", "type": "var_assignment"}, "target": {"label": "notFulfilled", "type": "var"}, "type": "assignment"}, {"source": {"label": "notFulfilled_1", "type": "var_assignment"}, "target": {"label": "status_0", "type": "var_assignment"}, "type": "data_dependency"}, {"source": {"label": "failedActivityConstraints", "type": "var"}, "target": {"label": "addAll", "type": "method"}, "type": "has_method"}, {"source": {"label": "notFulfilled_2", "type": "var_assignment"}, "target": {"label": "notFulfilled", "type": "var"}, "type": "assignment"}, {"source": {"label": "notFulfilled_2", "type": "var_assignment"}, "target": {"label": "status_0", "type": "var_assignment"}, "type": "data_dependency"}, {"source": {"label": "constraint", "type": "var"}, "target": {"label": "fulfilled", "type": "method"}, "type": "has_method"}]}
